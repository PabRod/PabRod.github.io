<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>PabRod - R</title><link href="https://pabrod.github.io/" rel="alternate"></link><link href="https://pabrod.github.io/feeds/tag-r.atom.xml" rel="self"></link><id>https://pabrod.github.io/</id><updated>2018-12-02T14:22:33+01:00</updated><entry><title>Animations in R</title><link href="https://pabrod.github.io/animations-r-en.html" rel="alternate"></link><published>2018-12-02T14:22:33+01:00</published><updated>2018-12-02T14:22:33+01:00</updated><author><name>Pablo Rodríguez-Sánchez</name></author><id>tag:pabrod.github.io,2018-12-02:/animations-r-en.html</id><summary type="html">&lt;p&gt;How to make animations in R using ggplot2 and gganimate&lt;/p&gt;</summary><content type="html">&lt;script src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML' async&gt;&lt;/script&gt;

&lt;p&gt;I've recently discovered the package &lt;em&gt;gganimate&lt;/em&gt; thanks to this
&lt;a href="http://blog.schochastics.net/post/beautiful-chaos-the-double-pendulum/"&gt;brilliant
example&lt;/a&gt;.
I've been playing with the package during this weekend, and I created
some examples that I spread through
&lt;a href="https://twitter.com/DonMostrenco/status/1068791278173908992"&gt;Twitter&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Some Twitter users showed interest in knowing more. I hope this short
tutorial can satisfy them.&lt;/p&gt;
&lt;h2&gt;Libraries used&lt;/h2&gt;
&lt;p&gt;We're going to need the following libraries:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;    # Numerical
    library(pracma) # To calculate the Taylor polynomials
    library(reshape) # For using melt

    # Display
    library(ggplot2) # For plotting
    library(ggthemes) # Also for plotting
    library(gganimate) # For animating. Install using devtools::install_github(&amp;#39;thomasp85/gganimate&amp;#39;)
    library(kableExtra) # To display nice tables
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;Animating a moving particle&lt;/h2&gt;
&lt;p&gt;Here we'll generate a moving particle. First, we need the positions in
time. In our case, the dynamical equations will be given by:&lt;/p&gt;
&lt;p&gt;$$ \begin{cases} x(t) = cos(t) \\ y(t) = sin(2t) \end{cases}$$&lt;/p&gt;
&lt;p&gt;So we generate the series and store them in a dataframe:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;    ts &lt;span class="o"&gt;&amp;lt;-&lt;/span&gt; &lt;span class="kp"&gt;seq&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="m"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="m"&gt;2&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="kc"&gt;pi&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; length.out &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="m"&gt;100&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    xs &lt;span class="o"&gt;&amp;lt;-&lt;/span&gt; &lt;span class="kp"&gt;cos&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;ts&lt;span class="p"&gt;)&lt;/span&gt;
    ys &lt;span class="o"&gt;&amp;lt;-&lt;/span&gt; &lt;span class="kp"&gt;sin&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="m"&gt;2&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;ts&lt;span class="p"&gt;)&lt;/span&gt;

    particle &lt;span class="o"&gt;&amp;lt;-&lt;/span&gt; &lt;span class="kt"&gt;data.frame&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;ts &lt;span class="o"&gt;=&lt;/span&gt; ts&lt;span class="p"&gt;,&lt;/span&gt; xs &lt;span class="o"&gt;=&lt;/span&gt; xs&lt;span class="p"&gt;,&lt;/span&gt; ys &lt;span class="o"&gt;=&lt;/span&gt; ys&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;The code for generating the animation follows a very similar syntax to
&lt;em&gt;ggplot&lt;/em&gt;. In this case, we indicate that the values of &lt;em&gt;ts&lt;/em&gt; should be
used as the transition time.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;    ggplot(data = particle) +
      geom_point(aes(x = xs, y = ys), col = &amp;#39;red&amp;#39;) + # Generate the plot
      theme_tufte() + # Make ...
      labs(x = &amp;#39;x&amp;#39;, y = &amp;#39;y&amp;#39;) + # ... it ...
      scale_y_continuous(limits = c(-2, 2)) + # ... look ...
      guides(col = FALSE) + # ... pretty.
      transition_time(ts) + # And animate!
      ease_aes(&amp;#39;linear&amp;#39;)
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;img alt="a" src="images/2018-12/Movement-1.gif"&gt;&lt;/p&gt;
&lt;h2&gt;Animating a Taylor series&lt;/h2&gt;
&lt;p&gt;Let's see now a more complex example. Our purpose is to explore Taylor
polynomials of different degrees approximating the function&lt;/p&gt;
&lt;p&gt;$$f(x) = cos(\frac{3x}{2}) e^{-x} $$&lt;/p&gt;
&lt;p&gt;around a given point.&lt;/p&gt;
&lt;p&gt;Thus, we begin creating the function:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;    f &lt;span class="o"&gt;&amp;lt;-&lt;/span&gt; &lt;span class="kr"&gt;function&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;x&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
      &lt;span class="kp"&gt;cos&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="m"&gt;1.5&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;x&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="kp"&gt;exp&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;x&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;In this case, we want to compare how good is the performance of Taylor
polynomials of different orders. The data we have to generate is a bit
more complex than before.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;    xs &lt;span class="o"&gt;&amp;lt;-&lt;/span&gt; &lt;span class="kp"&gt;seq&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="m"&gt;-2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="m"&gt;2&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="kc"&gt;pi&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; length.out &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="m"&gt;1500&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="c1"&gt;# Values of x&lt;/span&gt;
    x0 &lt;span class="o"&gt;&amp;lt;-&lt;/span&gt; &lt;span class="m"&gt;1&lt;/span&gt; &lt;span class="c1"&gt;# Value of x where the Taylor series will be centered&lt;/span&gt;
    ys &lt;span class="o"&gt;&amp;lt;-&lt;/span&gt; &lt;span class="kt"&gt;matrix&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="m"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; nrow &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="kp"&gt;length&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;xs&lt;span class="p"&gt;),&lt;/span&gt; ncol &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="m"&gt;9&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="kr"&gt;for&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;i &lt;span class="kr"&gt;in&lt;/span&gt; &lt;span class="m"&gt;1&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="m"&gt;9&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="c1"&gt;# Extract Taylor polynomials of orders 0 to 8&lt;/span&gt;
      order &lt;span class="o"&gt;&amp;lt;-&lt;/span&gt; i &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="m"&gt;1&lt;/span&gt; &lt;span class="c1"&gt;# Indexes have to be positive, but first order is 0&lt;/span&gt;
      &lt;span class="kr"&gt;if&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;order &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="m"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="c1"&gt;# A Taylor polynomial of order zero is just...&lt;/span&gt;
        ys&lt;span class="p"&gt;[,&lt;/span&gt;i&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;-&lt;/span&gt; f&lt;span class="p"&gt;(&lt;/span&gt;x0&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="c1"&gt;# ... a constant function&lt;/span&gt;
      &lt;span class="p"&gt;}&lt;/span&gt; &lt;span class="kr"&gt;else&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        taylor_coefs &lt;span class="o"&gt;&amp;lt;-&lt;/span&gt; taylor&lt;span class="p"&gt;(&lt;/span&gt;f &lt;span class="o"&gt;=&lt;/span&gt; f&lt;span class="p"&gt;,&lt;/span&gt; x0 &lt;span class="o"&gt;=&lt;/span&gt; x0&lt;span class="p"&gt;,&lt;/span&gt; n &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="kp"&gt;order&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="c1"&gt;# Get polynomial&lt;/span&gt;
        ys&lt;span class="p"&gt;[,&lt;/span&gt;i&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;-&lt;/span&gt; polyval&lt;span class="p"&gt;(&lt;/span&gt;taylor_coefs&lt;span class="p"&gt;,&lt;/span&gt; xs&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="c1"&gt;# Evaluate polynomial&lt;/span&gt;
      &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;

    &lt;span class="c1"&gt;# Rewrite as dataframe&lt;/span&gt;
    df &lt;span class="o"&gt;&amp;lt;-&lt;/span&gt; &lt;span class="kt"&gt;data.frame&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;ys&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="kp"&gt;colnames&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;df&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;-&lt;/span&gt; &lt;span class="kp"&gt;seq&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="m"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="m"&gt;8&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    df &lt;span class="o"&gt;&amp;lt;-&lt;/span&gt; melt&lt;span class="p"&gt;(&lt;/span&gt;df&lt;span class="p"&gt;)&lt;/span&gt;
    df &lt;span class="o"&gt;&amp;lt;-&lt;/span&gt; &lt;span class="kp"&gt;cbind&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;df&lt;span class="p"&gt;,&lt;/span&gt; xs &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="kp"&gt;rep&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;xs&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="m"&gt;9&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt; f &lt;span class="o"&gt;=&lt;/span&gt; f&lt;span class="p"&gt;(&lt;/span&gt;xs&lt;span class="p"&gt;))&lt;/span&gt;
    &lt;span class="kp"&gt;colnames&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;df&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;-&lt;/span&gt; &lt;span class="kt"&gt;c&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;order&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;ys&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;xs&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;f&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;The resulting dataframe is a collection of polynomials of different
orders evaluated at each point in &lt;em&gt;xs&lt;/em&gt;. Additionally, we added the
values of the original function &lt;em&gt;f(x)&lt;/em&gt;, also at each point:&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr class="header"&gt;
&lt;th align="left"&gt;order&lt;/th&gt;
&lt;th align="right"&gt;ys&lt;/th&gt;
&lt;th align="right"&gt;xs&lt;/th&gt;
&lt;th align="right"&gt;f&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr class="odd"&gt;
&lt;td align="left"&gt;0&lt;/td&gt;
&lt;td align="right"&gt;0.0260228&lt;/td&gt;
&lt;td align="right"&gt;-2.000000&lt;/td&gt;
&lt;td align="right"&gt;-7.315110&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class="even"&gt;
&lt;td align="left"&gt;0&lt;/td&gt;
&lt;td align="right"&gt;0.0260228&lt;/td&gt;
&lt;td align="right"&gt;-1.994474&lt;/td&gt;
&lt;td align="right"&gt;-7.265955&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class="odd"&gt;
&lt;td align="left"&gt;0&lt;/td&gt;
&lt;td align="right"&gt;0.0260228&lt;/td&gt;
&lt;td align="right"&gt;-1.988948&lt;/td&gt;
&lt;td align="right"&gt;-7.216622&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class="even"&gt;
&lt;td align="left"&gt;0&lt;/td&gt;
&lt;td align="right"&gt;0.0260228&lt;/td&gt;
&lt;td align="right"&gt;-1.983423&lt;/td&gt;
&lt;td align="right"&gt;-7.167120&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class="odd"&gt;
&lt;td align="left"&gt;0&lt;/td&gt;
&lt;td align="right"&gt;0.0260228&lt;/td&gt;
&lt;td align="right"&gt;-1.977897&lt;/td&gt;
&lt;td align="right"&gt;-7.117454&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class="even"&gt;
&lt;td align="left"&gt;0&lt;/td&gt;
&lt;td align="right"&gt;0.0260228&lt;/td&gt;
&lt;td align="right"&gt;-1.972371&lt;/td&gt;
&lt;td align="right"&gt;-7.067632&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;A static plot will look like:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;    ggplot(data = df) +
      geom_point(aes(x = xs, y = ys, col = order)) + # Generate basic plot
      geom_point(aes(x = xs, y = f)) + # Plot also original function
      geom_point(aes(x = x0, y = f(x0)), col = &amp;#39;black&amp;#39;, size = 5) + # Remark initial point
      theme_tufte() + # Make it ...
      labs(x = &amp;#39;x&amp;#39;, y = &amp;#39;y&amp;#39;) + # ... look ...
      scale_y_continuous(limits = c(-2, 2)) # ... pretty.
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;img alt="a" src="images/2018-12/Plot-static-1.png"&gt;&lt;/p&gt;
&lt;p&gt;In order to animate it, now we will use the command
&lt;em&gt;transition_states&lt;/em&gt;, using &lt;em&gt;order&lt;/em&gt; (the order of the Taylor polynomial)
as the animation parameter. The parameters &lt;em&gt;transition_length&lt;/em&gt; and
&lt;em&gt;state_length&lt;/em&gt; control how much time each state stays in screen, and
how long the transition between states should look.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;    ggplot(data = df) +
      geom_point(aes(x = xs, y = ys), col = &amp;#39;red&amp;#39;) + # Add basic plot
      geom_point(aes(x = xs, y = f)) + # Plot also original function
      geom_point(aes(x = x0, y = f(x0)), col = &amp;#39;red&amp;#39;, size = 5) + # Remark initial point
      theme_tufte() + # Make ...
      labs(x = &amp;#39;x&amp;#39;, y = &amp;#39;y&amp;#39;) + # ... it ...
      scale_y_continuous(limits = c(-2, 2)) + # ... look ...
      guides(col = FALSE) + # ... pretty.
      transition_states(order, transition_length = 1, state_length = 0.5) + # And animate!
      ease_aes(&amp;#39;linear&amp;#39;)
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;img alt="a" src="images/2018-12/Plot-animated-1.gif"&gt;&lt;/p&gt;
&lt;p&gt;The result could not look nicer!&lt;/p&gt;
&lt;p&gt;PS: If you liked this post, &lt;a href="https://www.geogebra.org/m/CeW2gCzH"&gt;this
visualization&lt;/a&gt; I made in &lt;em&gt;GeoGebra&lt;/em&gt;
some time ago may also be of your interest.&lt;/p&gt;</content><category term="math"></category><category term="R"></category></entry><entry><title>The spectrum of my personal accountancy</title><link href="https://pabrod.github.io/spectrum-accountancy-en.html" rel="alternate"></link><published>2018-11-28T13:54:29+01:00</published><updated>2018-11-28T13:54:29+01:00</updated><author><name>Pablo Rodríguez-Sánchez</name></author><id>tag:pabrod.github.io,2018-11-28:/spectrum-accountancy-en.html</id><summary type="html">&lt;p&gt;Application of Fourier analysis to a personal accountancy timeseries&lt;/p&gt;</summary><content type="html">&lt;script src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML' async&gt;&lt;/script&gt;

&lt;p&gt;Since year 2012, I keep and maintain a &lt;em&gt;.csv&lt;/em&gt; file containing
information about my bank accounts. The most relevant data is the time
series of the total amount of money vs. date. The table below shows a
small subset of this data:&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr class="header"&gt;
&lt;th align="left"&gt;Date&lt;/th&gt;
&lt;th align="right"&gt;Total&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr class="odd"&gt;
&lt;td align="left"&gt;2012-09-26&lt;/td&gt;
&lt;td align="right"&gt;641.52&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class="even"&gt;
&lt;td align="left"&gt;2012-09-24&lt;/td&gt;
&lt;td align="right"&gt;703.52&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class="odd"&gt;
&lt;td align="left"&gt;2012-09-22&lt;/td&gt;
&lt;td align="right"&gt;723.52&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class="even"&gt;
&lt;td align="left"&gt;2012-09-19&lt;/td&gt;
&lt;td align="right"&gt;755.52&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class="odd"&gt;
&lt;td align="left"&gt;2012-09-18&lt;/td&gt;
&lt;td align="right"&gt;765.52&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;When plotted, the data looks as noisy as the example on the figure below. The most noticeable regularity is the periodic increment at the end of each month, corresponding with the &lt;strong&gt;pay day&lt;/strong&gt;... followed by a big expenditure corresponding to paying the &lt;strong&gt;rent&lt;/strong&gt;. Notice also the higher pay in late June, corresponding to the summer extra salary that is customarily applied in several countries. The timeseries looks irregular, but there is some clear periodical component on it.&lt;/p&gt;
&lt;p&gt;&lt;img alt="a" src="images/2018-11/Plot-data-1.png"&gt;&lt;/p&gt;
&lt;p&gt;I know that the Fourier transform of a continuous timeseries is the perfect tool for spotting underlying periodicities. But my timeseries is uneven and discontinous. How can we fix this?&lt;/p&gt;
&lt;h2&gt;First step: Interpolation&lt;/h2&gt;
&lt;p&gt;The first problem, unevenness of data, can be solved by good old interpolation methods. The only tricky part here is that our &lt;em&gt;x&lt;/em&gt; coordinates are dates, so it is advisable to use &lt;em&gt;lubridate&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;I used the following:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kn"&gt;library&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;dplyr&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="kn"&gt;library&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;lubridate&lt;span class="p"&gt;)&lt;/span&gt;

first_day &lt;span class="o"&gt;&amp;lt;-&lt;/span&gt; &lt;span class="kp"&gt;min&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;df&lt;span class="o"&gt;$&lt;/span&gt;Date&lt;span class="p"&gt;)&lt;/span&gt;
last_day &lt;span class="o"&gt;&amp;lt;-&lt;/span&gt; &lt;span class="kp"&gt;max&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;df&lt;span class="o"&gt;$&lt;/span&gt;Date&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="c1"&gt;# Add a column with relative day as an integer&lt;/span&gt;
df &lt;span class="o"&gt;&amp;lt;-&lt;/span&gt; mutate&lt;span class="p"&gt;(&lt;/span&gt;df&lt;span class="p"&gt;,&lt;/span&gt; Day_index &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="kp"&gt;as.numeric&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;df&lt;span class="o"&gt;$&lt;/span&gt;Date &lt;span class="o"&gt;-&lt;/span&gt; first_day&lt;span class="p"&gt;))&lt;/span&gt;

&lt;span class="c1"&gt;# Create the time vector used for interpolation&lt;/span&gt;
all_days &lt;span class="o"&gt;&amp;lt;-&lt;/span&gt; &lt;span class="kp"&gt;seq&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;first_day&lt;span class="p"&gt;,&lt;/span&gt; last_day&lt;span class="p"&gt;,&lt;/span&gt; by &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="m"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
all_indices &lt;span class="o"&gt;&amp;lt;-&lt;/span&gt; &lt;span class="kp"&gt;seq&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="m"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kp"&gt;length&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;all_days&lt;span class="p"&gt;),&lt;/span&gt; by &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="m"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

daily_total &lt;span class="o"&gt;&amp;lt;-&lt;/span&gt; approx&lt;span class="p"&gt;(&lt;/span&gt;x &lt;span class="o"&gt;=&lt;/span&gt; df&lt;span class="o"&gt;$&lt;/span&gt;Day_index&lt;span class="p"&gt;,&lt;/span&gt; y &lt;span class="o"&gt;=&lt;/span&gt; df&lt;span class="o"&gt;$&lt;/span&gt;Total&lt;span class="p"&gt;,&lt;/span&gt; xout &lt;span class="o"&gt;=&lt;/span&gt; all_indices&lt;span class="p"&gt;,&lt;/span&gt; yright &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="kp"&gt;head&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;df&lt;span class="o"&gt;$&lt;/span&gt;Total&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="m"&gt;1&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;Second step: Fourier transform&lt;/h2&gt;
&lt;p&gt;For discrete, evenly spaced timeseries as the one we have after interpolation, fast Fourier transform can be used to estimate dominant frequencies. The fast Fourier transform or &lt;em&gt;FFT&lt;/em&gt; is defined as a function of an integer parameter &lt;em&gt;k&lt;/em&gt; and a set of &lt;em&gt;N&lt;/em&gt; complex numbers {&lt;em&gt;x&lt;/em&gt;&lt;sub&gt;0&lt;/sub&gt;, &lt;em&gt;x&lt;/em&gt;&lt;sub&gt;1&lt;/sub&gt;, ...&lt;em&gt;x&lt;/em&gt;&lt;sub&gt;&lt;em&gt;N&lt;/em&gt; − 1&lt;/sub&gt;}.&lt;/p&gt;
&lt;p&gt;The definition goes as follows:&lt;/p&gt;
&lt;p&gt;$$
X_k = FFT [ k; \lbrace x_n \rbrace] \equiv  \sum_{n=0}^{N-1} x_n\cdot e^{-i 2 \pi k \frac{n}{N}}
$$&lt;/p&gt;
&lt;p&gt;and the inverse:&lt;/p&gt;
&lt;p&gt;$$
x_n = FFT^{-1} [ n; \lbrace X_k \rbrace] \equiv  \frac{1}{N}\sum_{k=0}^{N-1} X_k \cdot  e^{i 2 \pi k \frac{n}{N}}
$$&lt;/p&gt;
&lt;p&gt;The &lt;em&gt;FFT&lt;/em&gt; can be used to estimate the spectrum of a signal. While doing this, it is important to note that &lt;em&gt;n&lt;/em&gt; and &lt;em&gt;k&lt;/em&gt; are unit-less vector indices. In order to link those indices with physical quantities as time and frequency, we could notice that:&lt;/p&gt;
&lt;p&gt;$$
x_n = x(n \cdot \Delta t) \equiv x(t_n)
$$&lt;/p&gt;
&lt;p&gt;where &lt;em&gt;Δ&lt;/em&gt;&lt;em&gt;t&lt;/em&gt; is the sampling period. If we take a number &lt;em&gt;N&lt;/em&gt; of samples, the final sample time should be:&lt;/p&gt;
&lt;p&gt;$$
t_{end} = N \cdot \Delta t \equiv t_N
$$&lt;/p&gt;
&lt;p&gt;Going to our first equation with all this in mind, we have:&lt;/p&gt;
&lt;p&gt;$$
X_k \equiv \\
\sum_{n=0}^{N-1} x_n \cdot e^{-i 2 \pi k \frac{n}{N}} = \\
\sum_{n=0}^{N-1} x(n \cdot \Delta t) \cdot e^{-i 2 \pi k \frac{n \cdot \Delta t}{t_{end}}} = \\
\sum_{t_n=0}^{t_{end}-\Delta t} x(t_n) \cdot e^{-i 2 \pi k \frac{t_n}{t_{end}}} = \\
\sum_{t_n=0}^{t_{end}-\Delta t} x(t_n) \cdot e^{-i \frac{2 \pi k}{t_{end}} t_n} = \\
\sum_{t_n=0}^{t_{end}-\Delta t} x(t_n) \cdot e^{-i \omega_k t_n}
$$&lt;/p&gt;
&lt;p&gt;so, the link between the indices &lt;em&gt;k&lt;/em&gt; and the corresponding physical frequencies &lt;em&gt;ω&lt;/em&gt;&lt;sub&gt;&lt;em&gt;k&lt;/em&gt;&lt;/sub&gt; is given by:&lt;/p&gt;
&lt;p&gt;$$
\omega_k = \frac{2 \pi}{t_{end}} k
$$&lt;/p&gt;
&lt;p&gt;We just added units (and thus, physical) significance to the indexes &lt;em&gt;k&lt;/em&gt; and &lt;em&gt;n&lt;/em&gt;!&lt;/p&gt;
&lt;p&gt;The (quite primitive) code I used for doing this is:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;    fft_spectrum &lt;span class="o"&gt;&amp;lt;-&lt;/span&gt; &lt;span class="kr"&gt;function&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;ts&lt;span class="p"&gt;,&lt;/span&gt; ys&lt;span class="p"&gt;,&lt;/span&gt; as.freq &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="kc"&gt;TRUE&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
      &lt;span class="c1"&gt;# Translate k indices into frequencies&lt;/span&gt;
      tEnd &lt;span class="o"&gt;&amp;lt;-&lt;/span&gt; &lt;span class="kp"&gt;tail&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;ts&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="m"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
      fs &lt;span class="o"&gt;&amp;lt;-&lt;/span&gt; &lt;span class="kp"&gt;seq&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="m"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kp"&gt;length&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;ys&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="m"&gt;-1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;/&lt;/span&gt; tEnd &lt;span class="c1"&gt;# In T^-1 units (typically Hz, if the time is in seconds)&lt;/span&gt;

      &lt;span class="c1"&gt;#Perform fast Fourier transform&lt;/span&gt;
      Xk &lt;span class="o"&gt;&amp;lt;-&lt;/span&gt; &lt;span class="kp"&gt;Mod&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;fft&lt;span class="p"&gt;(&lt;/span&gt;ys&lt;span class="p"&gt;))&lt;/span&gt;

      &lt;span class="kr"&gt;if&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;as.freq&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="c1"&gt;# Use frequencies&lt;/span&gt;
        &lt;span class="kt"&gt;list&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;f &lt;span class="o"&gt;=&lt;/span&gt; fs&lt;span class="p"&gt;,&lt;/span&gt; Xk &lt;span class="o"&gt;=&lt;/span&gt; Xk&lt;span class="p"&gt;)&lt;/span&gt;
      &lt;span class="p"&gt;}&lt;/span&gt; &lt;span class="kr"&gt;else&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="c1"&gt;# Use periods&lt;/span&gt;
        &lt;span class="kt"&gt;list&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;T&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="m"&gt;1&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;fs&lt;span class="p"&gt;,&lt;/span&gt; Xk &lt;span class="o"&gt;=&lt;/span&gt; Xk&lt;span class="p"&gt;)&lt;/span&gt;
      &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;Results&lt;/h2&gt;
&lt;p&gt;After applying the two algorithms described above I find the following distribution of the relative lengths of each period:&lt;/p&gt;
&lt;p&gt;&lt;img alt="b" src="images/2018-11/Frequencies-1.png"&gt;&lt;/p&gt;
&lt;p&gt;Note that the strengths corresponding to periods of &lt;em&gt;30&lt;/em&gt; and &lt;em&gt;31&lt;/em&gt; days are higher than their neighbors, corresponding to pay-days and monthly payments. Even my very basic algorithm could see it!&lt;/p&gt;
&lt;p&gt;&lt;em&gt;PS: I removed several details, plus trimmed both vertical and horizontal scales. I did this in order to keep my privacy. After all, the FFT is an invertible operation!&lt;/em&gt;&lt;/p&gt;</content><category term="math"></category><category term="R"></category></entry><entry><title>Embedding a Shiny app inside my blog</title><link href="https://pabrod.github.io/embed-shiny-en.html" rel="alternate"></link><published>2018-05-05T15:54:09+02:00</published><updated>2018-05-05T15:54:09+02:00</updated><author><name>Pablo Rodríguez-Sánchez</name></author><id>tag:pabrod.github.io,2018-05-05:/embed-shiny-en.html</id><summary type="html">&lt;p&gt;Embedding shiny apps inside an html page&lt;/p&gt;</summary><content type="html">&lt;p&gt;Some years ago, I started experimenting with the computing language &lt;em&gt;R&lt;/em&gt;. I have to confess that I don't feel fully comfortable with its syntax, which I find particularly difficult. But I forced myself to get used to it. Why? My main reasons were two: &lt;a href="https://yihui.name/knitr/"&gt;knitr&lt;/a&gt; and &lt;a href="https://shiny.rstudio.com"&gt;shiny&lt;/a&gt;.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Knitr&lt;/strong&gt; is the perfect tool for literate computing. It allows the user to input a combination of code and markdown text providing a clean, human-readable document as output. Indeed, I'm using knitr for writing parts of this website (for example, the &lt;a href="https://pabrod.github.io/pages/sci-comm-en.html"&gt;dissemination section&lt;/a&gt;).&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Shiny&lt;/strong&gt; is great for making interactive apps, and publishing them as easy-to-use webpages.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;For more (and certainly better) information... just google some tutorials. In this short entry, I only want to show an example of what shiny can do (and see how good it works with my new blog).&lt;/p&gt;
&lt;p&gt;Take a look at the following simulation I made some years ago to teach some basic ideas about statistical inference:&lt;/p&gt;
&lt;iframe src="https://pabrod.shinyapps.io/shiny/"
        style="border: 2px solid black; width: 100%; height: 1000px;"&gt;&lt;/iframe&gt;

&lt;p&gt;The steps followed were:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Write the app itself. Of course, this is the difficult part.&lt;/li&gt;
&lt;li&gt;Publish it. The easiest way is uploading it to &lt;a href="https://www.shinyapps.io"&gt;ShinyApps&lt;/a&gt;. The most popular &lt;em&gt;R&lt;/em&gt; editor, &lt;a href="https://www.rstudio.com"&gt;RStudio&lt;/a&gt;, can do this almost automatically.&lt;/li&gt;
&lt;li&gt;Once this two steps are made, the insertion code I've used is as simple as:&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;code&gt;&amp;lt;iframe src="https://pabrod.shinyapps.io/shiny/"
        style="border: 2px solid black; width: 100%; height: 1000px;"&amp;gt;&amp;lt;/iframe&amp;gt;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;I'm a big fan of simulation and interactive teaching. More apps will be published soon. Some of them can be previewed in &lt;a href="https://www.geogebra.org/u/pablorodriguez"&gt;GeoGebraTube&lt;/a&gt;.&lt;/p&gt;</content><category term="r"></category><category term="simulation"></category><category term="how-to"></category></entry></feed>